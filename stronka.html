<html>
  <head>
    <title>Ktm sx85</title>
    <meta charset="UTF-8" />
    <style>
      .rotate {
        display: inline-block;
        animation: spin 2s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .round-img {
        border-radius: 50%;
        object-fit: cover;
        width: 150px;
        height: 150px;
        /* Możesz zmienić rozmiar według uznania */
      }
      .bounce {
        position: absolute;
        top: 350px;
        left: 0;
        animation: bounce-horizontal 3s linear infinite alternate;
      }
      @keyframes bounce-horizontal {
        0% {
          left: 0;
        }
        100% {
          left: calc(100vw - 150px);
        }
      }
      .sound-blocks-container {
        display: flex;
        gap: 20px;
        margin-top: 40px;
      }
      .sound-block {
        min-width: 120px;
        min-height: 60px;
        background: #e0e0ff;
        border-radius: 18px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
        cursor: grab;
        user-select: none;
        border: 2px solid #b0b0ff;
        transition: box-shadow 0.2s;
      }
      .sound-block:active {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
      }
    </style>
  </head>
  <body>
    <h2>Klocki dźwiękowe</h2>
    <div class="sound-blocks-container" id="instrument-palette">
      <div class="sound-block" draggable="true" data-type="bass">🎸 Bass</div>
      <div class="sound-block" draggable="true" data-type="trumpet">
        🎺 Trumpet
      </div>
      <div class="sound-block" draggable="true" data-type="beat">🥁 Beat</div>
      <div class="sound-block" draggable="true" data-type="cymbalki">
        🔔 Cymbałki
      </div>
      <div class="sound-block" draggable="true" data-type="g-acoustic">
        🎼 Gitara akustyczna
      </div>
    </div>
    <h2>Kreator dźwięków</h2>
    <form id="sound-upload-form" style="margin-bottom: 24px">
      <input
        type="file"
        id="sound-file-input"
        accept="audio/wav,audio/x-wav,audio/wave,audio/aiff,audio/x-aiff"
      />
      <input
        type="text"
        id="sound-name-input"
        placeholder="Nazwa dźwięku"
        style="margin-left: 8px"
      />
      <button
        type="submit"
        style="
          margin-left: 8px;
          padding: 6px 16px;
          border-radius: 8px;
          border: none;
          background: #b0b0ff;
          cursor: pointer;
        "
      >
        Dodaj dźwięk
      </button>
    </form>
    <div
      id="note-picker-modal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.3);
        align-items: center;
        justify-content: center;
        z-index: 1000;
      "
    >
      <div
        style="
          background: #fff;
          padding: 30px 40px;
          border-radius: 16px;
          box-shadow: 0 4px 24px rgba(0, 0, 0, 0.18);
          text-align: center;
        "
      >
        <h3>Wybierz nutę</h3>
        <div
          id="note-buttons"
          style="
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 20px 0;
          "
        ></div>
        <button
          onclick="document.getElementById('note-picker-modal').style.display='none'"
          style="
            margin-top: 10px;
            padding: 8px 18px;
            border-radius: 8px;
            border: none;
            background: #eee;
            cursor: pointer;
          "
        >
          Anuluj
        </button>
      </div>
    </div>
    <h2>Oś czasu (Timeline)</h2>
    <div
      id="timeline-container"
      style="
        overflow-x: auto;
        background: #f8f8ff;
        border: 2px solid #b0b0ff;
        border-radius: 12px;
        padding: 24px 0 24px 60px;
        margin-bottom: 32px;
        position: relative;
        min-width: 600px;
      "
    >
      <div
        id="timeline-axis"
        style="
          position: absolute;
          left: 0;
          top: 0;
          width: 100%;
          height: 24px;
          display: flex;
          align-items: center;
        "
      ></div>
      <div
        id="timeline-tracks"
        style="display: flex; flex-direction: column; gap: 18px"
      ></div>
    </div>
    <button
      id="add-bars-btn"
      style="
        padding: 6px 18px;
        font-size: 1em;
        border-radius: 8px;
        background: #b0b0ff;
        color: #222;
        border: none;
        cursor: pointer;
        margin-bottom: 10px;
      "
    >
      Dodaj 4 takty
    </button>
    <h2>Sekwencery</h2>
    <div id="sequencers-area">
      <!-- Sekwencery będą tu dynamicznie dodawane -->
    </div>
    <button
      id="add-sequencer"
      style="
        padding: 10px 24px;
        font-size: 1em;
        border-radius: 10px;
        background: #b0b0ff;
        color: #222;
        border: none;
        cursor: pointer;
        margin-top: 10px;
      "
    >
      Dodaj sekwencer
    </button>
    <button
      id="play-all-sequencers"
      style="
        padding: 10px 24px;
        font-size: 1em;
        border-radius: 10px;
        background: #4caf50;
        color: #fff;
        border: none;
        cursor: pointer;
        margin-bottom: 20px;
      "
    >
      Odtwórz wszystkie sekwencery
    </button>
    <script>
      // Nuty do wyboru
      const NOTES = ["do", "re", "mi", "fa", "sol", "la", "si", "do"];
      // Mapowanie instrumentów na parametry dźwięku i typ (melodyczny/perkusyjny)
      const instrumentSounds = {
        Bass: {
          type: "sawtooth",
          freq: 55,
          duration: 0.4,
          icon: "🎸",
          melodic: false,
        },
        Trumpet: {
          type: "square",
          freq: 440,
          duration: 0.3,
          icon: "🎺",
          melodic: true,
        },
        Beat: {
          type: "triangle",
          freq: 120,
          duration: 0.18,
          icon: "🥁",
          melodic: false,
        },
        Cymbalki: {
          type: "sine",
          freq: 523,
          duration: 0.2,
          icon: "🔔",
          melodic: true,
        },
        "Gitara akustyczna": {
          type: "triangle",
          freq: 330,
          duration: 0.3,
          icon: "🎼",
          melodic: true,
        },
      };
      // Mapowanie nut na częstotliwości (skala C-dur, oktawa 4)
      const NOTE_FREQS = {
        do: 261.63,
        re: 293.66,
        mi: 329.63,
        fa: 349.23,
        sol: 392.0,
        la: 440.0,
        si: 493.88,
      };
      // Funkcja do wyboru nuty
      function pickNote(instrument, onPick) {
        const modal = document.getElementById("note-picker-modal");
        const btns = document.getElementById("note-buttons");
        btns.innerHTML = "";
        NOTES.forEach((note) => {
          const btn = document.createElement("button");
          btn.textContent = note;
          btn.style.padding = "10px 16px";
          btn.style.borderRadius = "8px";
          btn.style.border = "1px solid #b0b0ff";
          btn.style.background = "#f8f8ff";
          btn.style.cursor = "pointer";
          btn.onclick = () => {
            modal.style.display = "none";
            onPick(note);
          };
          btns.appendChild(btn);
        });
        modal.style.display = "flex";
      }
      // Name normalization to support diacritics differences (e.g., Cymbałki vs Cymbalki)
      function normalizeLabel(label) {
        return (label || "")
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toLowerCase()
          .trim();
      }
      function getInstrumentParamsByName(name) {
        const target = normalizeLabel(name);
        for (const key of Object.keys(instrumentSounds)) {
          if (normalizeLabel(key) === target) return instrumentSounds[key];
        }
        return null;
      }
      function playInstrument(name, note) {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const params = getInstrumentParamsByName(name);
        if (!params) {
          ctx.close();
          return;
        }
        osc.type = params.type;
        // Jeśli instrument melodyczny i nie podano nuty, domyślnie 'do'
        let freq = params.freq;
        if (params.melodic) {
          if (note && NOTE_FREQS[note]) {
            freq = NOTE_FREQS[note];
          } else {
            freq = NOTE_FREQS["do"];
          }
        }
        osc.frequency.value = freq;
        gain.gain.value = 0.2;
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        gain.gain.linearRampToValueAtTime(0, ctx.currentTime + params.duration);
        osc.stop(ctx.currentTime + params.duration);
        osc.onended = () => ctx.close();
      }
      document
        .querySelectorAll("#instrument-palette .sound-block")
        .forEach((block) => {
          block.addEventListener("click", () => {
            const name = block.textContent.replace(/^[^ ]+ /, "").trim();
            const instr = getInstrumentParamsByName(name);
            if (instr && instr.melodic) {
              pickNote(name, (note) => playInstrument(name, note));
            } else if (instr) {
              playInstrument(name);
            }
          });
        });
      // Drag and drop obsługa
      const blocks = document.querySelectorAll(".sound-block");
      let draggedBlock = null;
      blocks.forEach((block) => {
        block.addEventListener("dragstart", (e) => {
          draggedBlock = block;
          setTimeout(() => (block.style.opacity = "0.5"), 0);
        });
        block.addEventListener("dragend", (e) => {
          draggedBlock = null;
          block.style.opacity = "";
        });
      });
      // Funkcja do tworzenia nowego sekwencera
      let sequencerCount = 0;
      function createSequencer() {
        sequencerCount++;
        const wrapper = document.createElement("div");
        wrapper.style.marginBottom = "18px";
        wrapper.style.border = "1px solid #b0b0ff";
        wrapper.style.borderRadius = "12px";
        wrapper.style.padding = "10px";
        wrapper.style.background = "#f8f8ff";
        wrapper.style.position = "relative";
        wrapper.innerHTML = `
          <div class="sound-blocks-container sequencer" id="sequencer${sequencerCount}" style="min-height: 70px; background: #f8f8ff; border: 2px dashed #b0b0ff; margin-bottom: 8px;"></div>
          <button class="play-sequence" style="padding: 8px 18px; font-size: 1em; border-radius: 10px; background: #b0b0ff; color: #222; border: none; cursor: pointer;">Odtwórz w pętli</button>
          <button class="stop-sequence" style="padding: 8px 18px; font-size: 1em; border-radius: 10px; background: #eee; color: #222; border: none; cursor: pointer; margin-left: 8px;">Zatrzymaj</button>
          <button class="reset-sequence" style="padding: 8px 18px; font-size: 1em; border-radius: 10px; background: #eee; color: #222; border: none; cursor: pointer; margin-left: 8px;">Wyczyść</button>
        `;
        document.getElementById("sequencers-area").appendChild(wrapper);
        // Drag and drop obsługa dla nowego sekwencera
        const seq = wrapper.querySelector(".sequencer");
        seq.addEventListener("dragover", (e) => {
          e.preventDefault();
          seq.style.background = "#e0e0ff";
        });
        seq.addEventListener("dragleave", (e) => {
          seq.style.background = "#f8f8ff";
        });
        seq.addEventListener("drop", async (e) => {
          e.preventDefault();
          seq.style.background = "#f8f8ff";
          if (draggedBlock) {
            const isCustom =
              draggedBlock.getAttribute("data-type") === "custom";
            const newBlock = document.createElement("div");
            newBlock.className = "sound-block";
            if (isCustom) {
              // Custom sound: copy name and custom id
              newBlock.textContent = draggedBlock.textContent;
              newBlock.setAttribute("data-type", "custom");
              newBlock.setAttribute(
                "data-custom-id",
                draggedBlock.getAttribute("data-custom-id")
              );
            } else {
              newBlock.textContent = draggedBlock.textContent;
              newBlock.setAttribute(
                "data-instrument",
                draggedBlock.textContent.replace(/^[^ ]+ /, "").trim()
              );
            }
            seq.appendChild(newBlock);
          }
        });
        // Odtwarzanie w pętli
        let loopActive = false;
        const stepMs = 400; // czas dla 1/4
        const playBtn = wrapper.querySelector(".play-sequence");
        playBtn.addEventListener("click", () => {
          if (loopActive) return; // już gra
          loopActive = true;
          playBtn.disabled = true;
          const playOnce = async () => {
            const seqBlocks = Array.from(seq.querySelectorAll(".sound-block"));
            for (const block of seqBlocks) {
              block.style.background = "#b0b0ff";
              if (block.getAttribute("data-type") === "custom") {
                const customId = block.getAttribute("data-custom-id");
                const sound = await getCustomSoundById(customId);
                if (sound && sound.file) {
                  const url = URL.createObjectURL(sound.file);
                  await playCustomSoundAsync({ ...sound, dataUrl: url });
                  URL.revokeObjectURL(url);
                } else {
                  await new Promise((res) => setTimeout(res, stepMs));
                }
              } else {
                const name = block.textContent.replace(/^[^ ]+ /, "").trim();
                playInstrument(name);
                await new Promise((res) => setTimeout(res, stepMs));
              }
              block.style.background = "#e0e0ff";
            }
            if (loopActive) setTimeout(playOnce, 0);
          };
          playOnce();
        });
        // Zatrzymanie pętli i odblokowanie przycisku
        wrapper
          .querySelector(".stop-sequence")
          .addEventListener("click", () => {
            loopActive = false;
            playBtn.disabled = false;
          });
        // Reset sekwencera
        wrapper
          .querySelector(".reset-sequence")
          .addEventListener("click", () => {
            seq.innerHTML = "";
          });
      }
      // Dodaj pierwszy sekwencer na start
      createSequencer();
      document
        .getElementById("add-sequencer")
        .addEventListener("click", createSequencer);

      // --- IndexedDB for custom sounds ---
      function openSoundsDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open("CustomSoundsDB", 1);
          request.onupgradeneeded = function (e) {
            const db = e.target.result;
            if (!db.objectStoreNames.contains("sounds")) {
              db.createObjectStore("sounds", { keyPath: "id" });
            }
          };
          request.onsuccess = function (e) {
            resolve(e.target.result);
          };
          request.onerror = function (e) {
            reject(e);
          };
        });
      }
      async function saveCustomSoundIndexedDB(sound) {
        const db = await openSoundsDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction("sounds", "readwrite");
          tx.objectStore("sounds").put(sound);
          tx.oncomplete = resolve;
          tx.onerror = reject;
        });
      }
      async function getAllCustomSoundsIndexedDB() {
        const db = await openSoundsDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction("sounds", "readonly");
          const store = tx.objectStore("sounds");
          const req = store.getAll();
          req.onsuccess = () => resolve(req.result);
          req.onerror = reject;
        });
      }
      // Helper: get custom sound by id from IndexedDB
      async function getCustomSoundById(id) {
        const db = await openSoundsDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction("sounds", "readonly");
          const store = tx.objectStore("sounds");
          const req = store.get(id);
          req.onsuccess = () => resolve(req.result);
          req.onerror = reject;
        });
      }
      // Add custom sound block to palette (must be defined before use)
      async function addCustomSoundToPaletteAsync(sound) {
        const palette = document.getElementById("instrument-palette");
        const div = document.createElement("div");
        div.className = "sound-block";
        div.draggable = true;
        div.setAttribute("data-type", "custom");
        div.setAttribute("data-custom-id", sound.id);
        div.innerHTML = "🔊 " + sound.name;
        // Always create a fresh Blob URL for click
        div.addEventListener("click", async () => {
          let file = sound.file;
          if (!file) {
            // If loaded from IndexedDB, get the file
            const s = await getCustomSoundById(sound.id);
            file = s.file;
          }
          const url = URL.createObjectURL(file);
          await playCustomSoundAsync({ ...sound, dataUrl: url });
          URL.revokeObjectURL(url);
        });
        // Drag and drop support for custom blocks
        div.addEventListener("dragstart", (e) => {
          draggedBlock = div;
          setTimeout(() => (div.style.opacity = "0.5"), 0);
        });
        div.addEventListener("dragend", (e) => {
          draggedBlock = null;
          div.style.opacity = "";
        });
        palette.appendChild(div);
      }
      async function playCustomSoundAsync(sound) {
        // sound.dataUrl is a Blob URL
        return new Promise((resolve) => {
          const audio = new Audio(sound.dataUrl);
          audio.onended = resolve;
          audio.onerror = resolve; // resolve even if error
          audio.play();
        });
      }
      // On page load, restore custom sounds from IndexedDB
      getAllCustomSoundsIndexedDB().then((sounds) =>
        sounds.forEach(addCustomSoundToPaletteAsync)
      );
      // Handle upload
      document
        .getElementById("sound-upload-form")
        .addEventListener("submit", async (e) => {
          e.preventDefault();
          const fileInput = document.getElementById("sound-file-input");
          const nameInput = document.getElementById("sound-name-input");
          const file = fileInput.files[0];
          const name = nameInput.value.trim() || file?.name || "Custom";
          if (!file) return alert("Wybierz plik dźwiękowy!");
          // Store as Blob in IndexedDB, create Blob URL for playback
          const id = "custom-" + Date.now();
          // Store the file as a Blob in IndexedDB
          const sound = { id, name, file };
          await saveCustomSoundIndexedDB(sound);
          // For palette, create a fresh Blob URL for the icon/click
          const soundForPalette = {
            id,
            name,
            file,
            dataUrl: URL.createObjectURL(file),
          };
          addCustomSoundToPaletteAsync(soundForPalette);
          fileInput.value = "";
          nameInput.value = "";
        });
      // Play all sequencers at once
      document
        .getElementById("play-all-sequencers")
        .addEventListener("click", () => {
          // Find all play buttons in sequencers and click them if not already playing
          document.querySelectorAll(".play-sequence").forEach((btn) => {
            if (!btn.disabled) btn.click();
          });
        });

      // --- Infinite Timeline Logic ---
      let timelineLength = 16; // 16 steps (4 bars x 4)
      const stepWidth = 48; // px per step
      const timelineAxis = document.getElementById("timeline-axis");
      const timelineTracks = document.getElementById("timeline-tracks");
      const addBarsBtn = document.getElementById("add-bars-btn");
      function renderTimelineAxis() {
        timelineAxis.innerHTML = "";
        for (let i = 0; i < timelineLength; ++i) {
          const tick = document.createElement("div");
          tick.style.width = stepWidth + "px";
          tick.style.height = "24px";
          tick.style.borderLeft = i === 0 ? "2px solid #888" : "1px solid #bbb";
          tick.style.display = "flex";
          tick.style.alignItems = "center";
          tick.style.justifyContent = "center";
          tick.style.fontSize = "0.9em";
          tick.textContent = i % 4 === 0 ? i / 4 + 1 : "";
          timelineAxis.appendChild(tick);
        }
      }
      function renderTimelineTracks() {
        timelineTracks.innerHTML = "";
        trackNames.forEach((name, idx) => {
          const row = document.createElement("div");
          row.className = "timeline-track-row";
          row.style.position = "relative";
          row.style.height = "48px";
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.borderBottom = "1px solid #e0e0ff";
          // Label
          const label = document.createElement("div");
          label.textContent = name;
          label.style.position = "absolute";
          label.style.left = "-60px";
          label.style.width = "56px";
          label.style.textAlign = "right";
          label.style.fontWeight = "bold";
          row.appendChild(label);
          // Track area
          const trackArea = document.createElement("div");
          trackArea.className = "timeline-track-area";
          trackArea.style.position = "relative";
          trackArea.style.height = "100%";
          trackArea.style.width = timelineLength * stepWidth + "px";
          trackArea.style.display = "flex";
          trackArea.style.alignItems = "center";
          trackArea.style.gap = "0px";
          trackArea.setAttribute("data-track", name);
          row.appendChild(trackArea);
          timelineTracks.appendChild(row);
        });
      }
      // Initial render
      renderTimelineAxis();
      renderTimelineTracks();
      // Add bars button logic
      addBarsBtn.addEventListener("click", () => {
        timelineLength += 16; // Add 4 bars (16 steps)
        renderTimelineAxis();
        renderTimelineTracks();
        // Re-attach drag and drop
        attachTimelineDnD();
      });
      // Drag and drop to timeline (refactored for re-attach)
      function attachTimelineDnD() {
        let draggingBlockData = null;
        document
          .querySelectorAll("#instrument-palette .sound-block")
          .forEach((block) => {
            block.addEventListener("dragstart", (e) => {
              draggingBlockData = {
                type: block.getAttribute("data-type"),
                name: block.textContent.replace(/^[^ ]+ /, "").trim(),
                customId: block.getAttribute("data-custom-id") || null,
              };
            });
            block.addEventListener("dragend", (e) => {
              draggingBlockData = null;
            });
          });
        document
          .querySelectorAll(".timeline-track-area")
          .forEach((trackArea) => {
            trackArea.addEventListener("dragover", (e) => {
              e.preventDefault();
              trackArea.style.background = "#e0e0ff";
            });
            trackArea.addEventListener("dragleave", (e) => {
              trackArea.style.background = "";
            });
            trackArea.addEventListener("drop", (e) => {
              e.preventDefault();
              trackArea.style.background = "";
              if (!draggingBlockData) return;
              // Calculate step from mouse position
              const rect = trackArea.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const step = Math.floor(x / stepWidth);
              // Default block length: 1/4 (1 step)
              const blockLength = 1; // steps
              // Create block
              const block = document.createElement("div");
              block.className = "timeline-block";
              block.style.position = "absolute";
              block.style.left = step * stepWidth + "px";
              block.style.top = "8px";
              block.style.width = blockLength * stepWidth - 6 + "px";
              block.style.height = "32px";
              block.style.background = "#b0b0ff";
              block.style.borderRadius = "10px";
              block.style.display = "flex";
              block.style.alignItems = "center";
              block.style.justifyContent = "center";
              block.style.fontWeight = "bold";
              block.style.color = "#222";
              block.style.boxShadow = "0 2px 8px rgba(0,0,0,0.08)";
              block.style.cursor = "pointer";
              block.textContent = draggingBlockData.name;
              block.setAttribute("data-type", draggingBlockData.type);
              if (draggingBlockData.type === "custom") {
                block.setAttribute(
                  "data-custom-id",
                  draggingBlockData.customId
                );
              }
              block.setAttribute("data-step", step);
              block.setAttribute("data-length", blockLength);
              trackArea.appendChild(block);
            });
          });
      }
      attachTimelineDnD();
      // TODO: Timeline playback logic (not yet implemented)
    </script>
  </body>
</html>
